# 4.4  Expanding Purpose

## Overview

Behaviors are intended to define various aspects of an application's literal behavior under various contextual circumstances. These circumstances and the functionality of the behavior through its operations define its purpose. Previously, the circumstances were only defined by the contexts themselves and any qualifications that the behavior may have for them, but there are settings for a behavior's contexts that can expand the purpose further.

These settings, described below, can be used individually or in combination to affect a change in how a behavior obtains or manages its contexts. The logging feature that has been worked on throughout this chapter can be expanded upon to better discuss what these settings can do. These changes not only work to better showcase the settings, but they also help realize one of the original intentions of logging, which was that logs could be routed to different outputs, not only the console as has been done so far.

First, there needs to be a context to differentiate console routing from the overall log settings:

```
Console Log Route : context Log Settings.
```

The `Log Settings` used so far is fine to define the underlying minimum log level, so the new context `Console Log Route` can simply be a descendant of that. The `Perform Logging` behavior should be updated for that as well:

```
Perform Console Logging ::
    logging per Console Log Route for {*Log Message*}: {route, messages}
        where messages is messages filtered by 
            [(message) => message(Level) >= route(Minimum Level)]?
    {
        Log Messages :: for {messages} 
            whenever |messages| > 0, 
            foreach message in messages?
                evaluate "Log: \(message)" as Console Message,
                \deactivate message;
    }.
```

There's not a lot of changes here, just swapping `Log Settings` for `Console Log Route`, renaming the behavior to `Perform Console Logging`, and renaming the behavior's context `settings` to `route`. However, this decouples the behavior of console logging from the general `Log Settings`.

Context descendants do not inherit the behaviors of their ancestors, so the `Maintain Log Settings`, [from earlier](4.2-from-when-to-whenever.md#reactive-behavior), will need to be updated similarly:

```
Maintain Console Log Route::
    maintain the existence of Console Log Route in accordance with App State: 
        {route, app}?
    {
        Stop Logging :: for {route, app} whenever app is shutting down?
            activate Log Message ["Stopping Logs", Level [Log Level (Debug)] ],
            deactivate settings;
    }.
```

These changes set the stage to move away from logging being console specific.



## Exclusivity

The first step to enable multiple log routes pertains to the concept of the contexts' exclusivity, which defines how contexts might be shared between behaviors. The term "shared" itself is actually a keyword, `shared`, to specify exclusivity, with its counterpart `unique`. By default, all behavior contexts are unique per instance of the same type of behavior.

In other words, if there were two `Console Log Route` contexts, there would be two `Perform Console Logging` behavior instances and any `Log Message` contexts that qualify for both would be split between them. Each `Console Log Route` would be unique to their instance of the `Perform Console Logging` behavior and each `Log Message` would be unique to only one of those instances.

This creates a problem for scaling the logging feature and for abstracting this behavior later. In consideration of the former, if there were a `File Log Route`, it would be reasonable to support multiple instances of such a route, perhaps so some messages were written to one file, or another file, or both. Using the default exclusivity, there would be no support for the same messages being written to both files. In consideration of the latter, if `Console Log Route` were [to be abstracted ](../chapter-7-abstracting-contexts-and-changes/7.1-contracts.md#with-behaviors)and this behavior were made to be generalized across multiple types of routes, then a message could not be logged for both the console and file.

To address this issue, `shared` can be specified for `{*Log Messages*}`, like so:

```
Perform Console Logging ::
    logging per Console Log Route for shared {*Log Message*}: {route, messages}
        where messages is messages filtered by 
            [(message) => message(Level) >= route(Minimum Level)]?
    {
        Log Messages :: for {messages} 
            whenever |messages| > 0, 
            foreach message in messages?
                evaluate "Log: \(message)" as Console Message,
                \deactivate message;
    }.
```

If a developer wants to be explicit, then `unique` can also be specified for `Console Log Route` without any change to this current functionality:

```
Perform Console Logging ::
    logging per unique Console Log Route for shared {*Log Message*}: 
        {route, messages}
        where messages is messages filtered by 
            [(message) => message(Level) >= route(Minimum Level)]?
    {
        Log Messages :: for {messages} 
            whenever |messages| > 0, 
            foreach message in messages?
                evaluate "Log: \(message)" as Console Message,
                \deactivate message;
    }.
```

`shared` should also be applied to the `Maintain Console Log Route` as well, so that `App State` could be shared across multiple route instances:

```
Maintain Console Log Route::
    maintain the existence of Console Log Route in accordance with shared App State: 
        {route, app}?
    {
        Stop Logging :: for {route, app} whenever app is shutting down?
            activate Log Message ["Stopping Logs", Level [Log Level (Debug)] ],
            deactivate settings;
    }.
```

The main consideration to be made when sharing contexts is what purpose multiple instances of the shared context will serve for the affected behavior. Are there qualifications that will still distribute the different instances of a shared context across behavior instances or is it expected for there to really only be one such context in the application? Both are valid scenarios for different purposes of a behavior.



## Fulfillment

\[Fulfillment applied to the relationship between Log Settings and App State.]



## Specifiers

\[Specifiers applied to destroying the routers when the Log Settings is destroyed, and Log Settings when App State's behavior is destroyed.]
