# 4.1  Revisiting Hello World!

## The Concept of Behavior

A "Behavior" is a construct that provides additional meaning to its required, and qualifying, contexts, with encapsulated operations that can react[^1] to changes in those contexts. The contexts associated with a behavior form a relationship that can be leveraged by the behavior and other behaviors/operations, [as seen later](../chapter-5-evaluating-through-compositions/5.1-composing-contexts.md). This reactivity and the conditional associations between contexts and their shared operations is at the heart of Contextual Programming, enabling programmers to more effectively develop dynamic applications.



## Registering

Before going over the internals of a behavior, it's best to understand how a behavior exists and what to expect of it. Behaviors require contexts that have been "registered". So far, there have been no such contexts explicitly registered. Doing so can be done with this generalized syntax, within an operation:

```
await some context as Registration
```

All contexts can be aliased as a `Registration`, which is a built-in construct that initiates functionality to persist the context, in this case, some instance of a context called `some context`. Once this is done, a behavior that requires a context of the same type as `some context` can evaluate `some context` to see whether it qualifies to be associated with the behavior and its other contexts, that is, if all of its required contexts exist and qualify. In some cases, multiple instances of behaviors can exist.

{% hint style="warning" %}
An instance of a behavior may be similar to an instance of an object in Object-Oriented Programming, although there are some differences. A behavior will be instanced, meaning it will exist with specific associations and will perform its functionality, if its context requirements are met. Once a behavior has its requirements met, any additional contexts (that cannot be associated with that behavior based on [how it is defined](4.4-expanding-purpose.md)) will be considered for additional behavior instances.

When a behavior can no longer continue to exist as an instance, namely because one of its contexts were [deregistered](4.1-revisiting-hello-world.md#deregistering). Then the remaining contexts are (usually, again depending on how its defined) considered for new behavior instances. This highlights one of the primary differences in instances, compared to Object-Oriented Programming, that being the internal data of a behavior instance may persist and be associated with a new behavior instance automatically.
{% endhint %}

### Introducing Console Output

One of the most basic behaviors is one that was, unknowingly, being used back in the [original Hello World! example](../chapter-3-evaluating-with-operations/3.1-hello-world.md). That code was:

```
Output hello world: when initialized?
    await "Hello World!" as Console Message.
```

There's no apparent registration occurring here, but the operation that handles `Console Message` will actually register it. Afterwards, a behavior that works with a `Console Output` context and any registered `Console Message` contexts will append each value of those `Console Messages` to a `Messages` list[^2] property of `Console Output`. The `Console Messages` are deregistered at a later time through another behavior to prevent unnecessary memory use. As part of the console's refresh cycle, any content in `Messages` of `Console Output` will be printed onto the console.

{% hint style="info" %}
One may be wondering, "How can I know in what ways a context, such as `Console Message` is being used?" In the modern era, IDE[^3]s play a vital role in software development. While the programmer looking at this awaiting code may not know all of the associations of `Console Message` and its conditional operations/behaviors, the IDE can, since it is always knowledgeable of how the `Console Message` is referenced and manipulated across those operations/behaviors. The short answer here is, a proper IDE should inform the programmer of everything they need to know for the contexts that the programmer is working with.
{% endhint %}

As described, that's quite a bit happening behind the scenes. The purpose of reducing all of that down to `await some string as Console Message` is to simplify the steps taken to output to the console, and to prevent the need to make `Console Output` a required context for any number of behaviors/operations. However, there may be times when it is appropriate to declare and register `Console Output` directly, and to have it as a dependency[^4].

In addition to other useful properties, `Console Output` has the aforementioned `Messages` property. The value of this property is exactly that which appears in the console to the user, including the user's [own active input text and previous responses](#user-content-fn-5)[^5], although word wrap to fit within the bounds of the console may change how it appears. Every message is assumed to be its own print statement, with an assumed [new line](#user-content-fn-6)[^6] at the end. Having direct access to this property is useful, as the contents of the console can be cleared by changing that property to be an empty list.

### Registering Console Output

The Hello World! example can be updated, based on the generalized syntax to register a context, to explicitly declare `Console Output`, like so:

```
Hello World :: when initialized?
    await output: Console Output; as Registration,
    output(Messages) is "Hello World!".
```

The first line, `Hello World :: when initialized?` is using the operation identifier in place of a name, since there are no dependencies for this operation, as was covered [recently](../chapter-3-evaluating-with-operations/3.3-operation-groups.md#performing-fizz-buzz). The second line is more pertinent to the current topic. `await output: Console Output; as Registration` is performing an inline declaration of a `Console Output` called `output`, then aliasing is as a `Registration`. This provides `output` for further use while also registering it so the console printing behavior mentioned previously can be initialized and begin working.

The last line, `output(Messages) is "Hello World!"` is assigning a single `String` to the list of `Messages` in `output`. This will result in `Messages` being a list with one item, the `String` that is `Hello World!`. This change will [later trigger](4.2-from-when-to-whenever.md#understanding-the-cycle) the console printing behavior to update the console's display, resulting in `Hello World!` being displayed to the user.

This example can be shortened further by setting `Messages` at the point of `output` being declared:

```
Hello World :: when initialized?
    await !: Console Output [Messages ["Hello World!"]]; as Registration.
```

This code is similar, but `output` is no longer named in the declaration, as it isn't needed beyond its registration, and the `Console Output` instance is initialized with `Messages` set to `"Hello World!"`, as is accomplished with the code `Console Output [Messages ["Hello World!"]]`.



## Deregistering

The opposite of registering is deregistering, which informs the runtime that the previously registered context (if it was registered, if not, nothing happens) should no longer be registered. Any behavior that was depending on the context will no longer have access to that context, so if its existence was required for the behavior to function, then the behavior will no longer work, and any relationships formed between other contexts due to that behavior are broken.

Deregistration is done in the same manner as registration, generally being:

```
await some context as Deregistration
```

As with most functionality in Contextual Programming, registration and the resulting behavior functionality does not [happen immediately](4.2-from-when-to-whenever.md#understanding-the-cycle). Knowing this, the following example will work to effectively cancel the output to the console:

```
Hello World :: when initialized?
    await output: Console Output [Messages ["Hello World!"]]; as Registration,
    await output as Deregistration.
```

The above code will deregister the registration of `output`, which will prevent the console printing behavior from initializing and outputting `Hello World!`.

[^1]: React, in this sense, means to be automatically performed. More specifically, behavior operations can be declared to be performed if a behavior's context(s) change in some way.

[^2]: A List in programming is a one-dimensional collection that can rather easily have items added and removed from it, much like an everyday list.

[^3]: IDE stands for Interactive Development Environment. These are software that parses a codebase and can inform a programmer about the code they are working with and also simplify a number of tasks that a programmer may wish to perform on the codebase.

[^4]: A dependency is any construct required by another construct for the latter to function as expected. All required contexts of a behavior or operation are dependencies. Some control flow qualifiers can also define dependencies with other operations.

[^5]: Both of these are appended to the `Messages` list in their own way as the result of user input.

[^6]: A new line, coded most often as `\n` in a string, is the same as using the `Enter` key when typing in a word document. The current line of text will end and the cursor will move to the next row to type any new text. It functions the same when printing to the console.
