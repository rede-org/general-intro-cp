# 4.1  Revisiting Hello World!

## The Concept of Behavior

A "Behavior" is a construct that provides additional meaning to its required, and qualifying, contexts, with encapsulated operations that can react[^1] to changes in those contexts. The contexts associated with a behavior form a relationship that can be leveraged by the behavior and other behaviors/operations, [as seen later](../chapter-5-evaluating-through-compositions/5.1-composing-contexts.md). This reactivity and the conditional associations between contexts and their shared operations is at the heart of Contextual Programming, enabling programmers to more effectively develop dynamic applications.



## Registering

Before going over the internals of a behavior, it's best to understand how a behavior exists and what to expect of it. Behaviors require contexts that have been "registered" to persist. So far, there have been not such contexts registered. Doing so can be done with this generalized syntax, within an operation:

```
await some context as Registration
```

All contexts can be aliased as a `Registration`, which is a built-in construct that initiates functionality to persist the context, in this case, some instance of a context called `some context`. Once this is done, a behavior that requires a context of the same type as `some context` can evaluate `some context` to see whether it qualifies to be associated with the behavior and its other contexts, that is, if all of its required contexts exist and qualify.

### Introducing Console Output

One of the most basic behaviors is one that was, unknowingly, being used back in the [original Hello World! example](../chapter-3-evaluating-with-operations/3.1-hello-world.md). That code was:

```
Output hello world: when initialized?
    await "Hello World!" as Console Message.
```

There's no apparent registration occurring here, but the operation that handles `Console Message` will actually register it. Afterwards, a behavior that works with a `Console Output` context and any registered `Console Message` contexts will append each value of those `Console Messages` to a `Messages` list[^2] property of `Console Output`. The `Console Messages` are deregistered at a later time through another behavior to prevent unnecessary memory use. As part of the console's refresh cycle, any content in `Messages` of `Console Output` will be printed onto the console.

As described, that's quite a bit happening behind the scenes. The purpose of reducing all of that down to `await some string as Console Message` is to simplify the steps taken to output to the console, and to prevent the need to make `Console Output` a required context for any number of behaviors/operations. However, there may be times when it is appropriate to declare and register `Console Output` directly, and to have it as a dependency[^3].

In addition to other useful properties, `Console Output` has the aforementioned `Messages` property. The value of this property is exactly that which appears in the console to the user, including the user's [own active input text and previous responses](#user-content-fn-4)[^4], although word wrap to fit within the bounds of the console may change how it appears. Every message is assumed to be its own print statement, with an assumed [new line](#user-content-fn-5)[^5] at the end. Having direct access to this property is useful, as the contents of the console can be cleared by changing that property to be an empty list.

### Registering Console Output

The Hello World! example can be updated, based on the generalized syntax to register a context, to explicitly declare `Console Output`, like so:

```
Hello World :: when initialized?
    await output: Console Output; as Registration,
    output(Messages) is "Hello World!".
```

The first line, `Hello World :: when initialized?` is using the operation identifier in place of a name, since there are no dependencies for this operation, as was covered [recently](../chapter-3-evaluating-with-operations/3.3-operation-groups.md#performing-fizz-buzz). The second line is more pertinent to the current topic. `await output: Console Output; as Registration` is performing an inline declaration of a `Console Output` called `output`, then aliasing is as a `Registration`. This provides `output` for further use while also registering it so the console printing behavior mentioned previously can be initialized and begin working.

The last line, `output(Messages) is "Hello World!"` is assigning a single `String` to the list of `Messages` in `output`. This will result in `Messages` being a list with one item, the `String` that is `Hello World!`. This change will [later trigger](4.2-from-when-to-whenever.md#understanding-the-cycle) the console printing behavior to update the console's display, resulting in `Hello World!` being displayed to the user.

This example can be shortened further by setting `Messages` at the point of `output` being declared:

```
Hello World :: when initialized?
    await !: Console Output [Messages ["Hello World!"]]; as Registration.
```

This code is similar, but `output` is no longer named in the declaration, as it isn't needed beyond its registration, and the `Console Output` instance is initialized with `Messages` set to `"Hello World!"`, as is accomplished with the code `Console Output [Messages ["Hello World!"]]`.

{% hint style="warning" %}
In Rede, `[ ]` denotes "stand-in", as in "the contents within will stand-in for whatever was otherwise expected". In this specific case, data identified as `Messages` with its own stand-in value of `"Hello World!"` will replace any concept of `Messages` within the `Console Output` that is being created.
{% endhint %}



## Deregistering

\[Detail the concept of deregistering and what that means for a behavior.]

[^1]: React, in this sense, means to be automatically performed. More specifically, behavior operations can be declared to be performed if a behavior's context(s) change in some way.

[^2]: A List in programming is a one-dimensional collection that can rather easily have items added and removed from it, much like an everyday list.

[^3]: A dependency is any construct required by another construct for the latter to function as expected. All required contexts of a behavior or operation are dependencies. Some control flow qualifiers can also define dependencies with other operations.

[^4]: Both of these are appended to the `Messages` list in their own way as the result of user input.

[^5]: A new line, coded most often as `\n` in a string, is the same as using the `Enter` key when typing in a word document. The current line of text will end and the cursor will move to the next row to type any new text. It functions the same when printing to the console.
