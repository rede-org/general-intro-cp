# 4.3  Working with Buckets

## Collection-Dependent Behaviors

Some behaviors will need to operate for every instance of a type of context. The [logging behavior](4.2-from-when-to-whenever.md#logging) created in the last chapter is an example of such a behavior. Up to this point, its declaration looks like:

```
Perform Logging ::
    logging per Log Settings for Log Message: {settings, message}
        when message(Level) >= settings(Minimum Level)?
    {
        Log :: for {message} when initialized?
            evaluate "Log: \(message)" as Console Message,
            \deactivate message;
    }.
```

As it is currently implemented, there will be an instance of this behavior for every `Log Message` (assuming there is only one `Log Settings` in the application). That instance will be destroyed after its initialization operation executes. There isn't anything wrong with this implementation, but it does require a bit more work by the application to continually cycle through new instances of the behavior. It also required the `Log Settings` to be maintained by another behavior so it would persist across the destruction of this behavior's instances.

These requirements can be removed by making `Perform Logging` dependent on the application's collection of `Log Message` instances rather than a single instance. Doing so can be done by updating the behavior to look like:

```
Perform Logging ::
    logging per Log Settings for {*Log Message*}: {settings, messages}
    {
        Evaluate Messages :: for {settings, messages} 
            whenever |messages| > 0, 
            foreach message in messages?
                evaluate message for settings,
                \deactivate message;
        
        Log :: message for {settings}
            when message(Level) >= settings(Minimum Level)?
                evaluate "Log: \(message)" as Console Message;
    }.
```

The first change to point out is `{*Log Message*}` replacing `Log Message` in the behavior description. This change is what makes the behavior collection-dependent. Surrounding a context type with curly braces and stars in Rede, generally as `{* "Context Type" *}`, defines what is called a "bucket" of those contexts. A bucket is an ordered[^1] collection of unique[^2] contexts. Contexts can be accessed sequentially (as shown above by `foreach message in messages`), by index (e.g., `messages(0)`), or by [context ID](../chapter-7-abstracting-contexts-and-changes/7.4-context-identifiers.md). When used in a behavior declaration, by default, all instances of the specified context will be provided to the behavior's bucket. However, that can be customized, as discussed [below](4.3-working-with-buckets.md#managing-the-collection-s).

By making the behavior dependent on a collection, an instance of `Log Settings` on its own will be enough to qualify an instance of the behavior, albeit with an empty `Log Message` bucket, which is fine for this behavior. Whenever the number of messages in the `Log Message` bucket is more than `0`, as specified by `whenever` [`|messages|`](#user-content-fn-3)[^3] `> 0`, the `Evaluate Messages` operation will reactively evaluate, being executed for every `message` that is now in the bucket.

Within this operation, there is a composition-based evaluation. `evaluate message for settings` initiates the evaluation of any operations that depend upon a `Log Message` and a composition that consists only of the `Log Settings`. This evaluation could extend beyond this behavior, to any other behavior that is working with the same `Log Settings` instance and has an operation for a single `Log Message`. It would not evaluate any operations that simply require any `Log Message` and a `Log Settings`, as that is not what is being specified by this evaluation.

The one operation that currently depends on a `Log Message` for that specific `Log Settings` instance is the `Perform Logging` behavior's `Log` operation, as also shown above. It will qualify if the message's log level meets the setting's minimum log level and will then evaluate the message as a `Console Message` with `Log:` prepended, just as logging was accomplished before these changes. Once that is done, `Evaluate Messages` will plan to deactivate the message, regardless of whether it was logged.

These changes accomplish the same functionality as before, but there no longer needs to be a behavior to maintain the `Log Settings` between `Log Message` instances. The single `Perform Logging` behavior instance created for the `Log Settings` will persist until `Log Settings` is deactivated, which also grants an improvement to performance.



## Managing the Collection(s)

The above changes are an improvement, but they can go a step further to make the behavior as a whole more focused and explicit in its purpose. This can be accomplished by altering what qualifies for the `Log Message` bucket.

There are a couple of ways to customize the contexts of a behavior's bucket(s). The second of which will be applied to the `Perform Logging` behavior.

### Sorting



### Filtering



\[Update logging to filter the messages of the behavior instead of for the operation.]

[^1]: Meaning that they maintain their arrangement, originally by the first added to the last added, but they can be re-arranged manually or by sorting.

[^2]: Meaning that the same context instance will not exist in a bucket more than once. If it already exists, any attempt to assign or add the instance will be ignored.

[^3]: The `|` symbol surrounding any collection will retrieve the number of elements in that collection.
