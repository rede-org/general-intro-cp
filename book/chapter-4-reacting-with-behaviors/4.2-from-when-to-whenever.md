# 4.2  From 'When' to 'Whenever'

## A Basic Behavior

When [revisiting Hello World!](4.1-revisiting-hello-world.md), a behavior that uses `Console Output` and `Console Message` was described. While it's great to understand the built-in behaviors of Rede, to really take advantage of Contextual Programming, one must be able to create behaviors. The generalized syntax to do so is very similar to that of an [operation group](../chapter-3-evaluating-with-operations/3.3-operation-groups.md), [as follows](#user-content-fn-1)[^1]:

```
"Behavior Identifier" ::
    "behavior name with [Context Types]": {"Context Names"} "Qualifications"?
    {
        [An Operation]
        [Another Operation]
    }.
```

There's an optional identifier, a name with specified context types, the names associated to those context types, any qualifications, then the behavior's operations. The symbols used throughout are the same, except the context names are enclosed in `{ }` instead of `< >`.&#x20;

{% hint style="info" %}
As explained [previously](../chapter-3-evaluating-with-operations/3.2-expanding-on-when.md#operations-with-multiple-contexts), the use of `< >` for operations is used in both an operation declaration and to explicitly define an operable to be evaluated. This creates a consistent connection between `< >` being used to signify a concept of operations. It has also been [previously](../chapter-3-evaluating-with-operations/3.3-operation-groups.md#getting-the-input) mentioned ([twice](../chapter-2-creating-context/2.1-organizing-data.md#defining-a-context)) that `{ }` denotes some kind of collection. In the case of a behavior declaration, it is a collection of contexts, which is referred to in Contextual Programming as a 'composition'.

Just as [operables have a purpose](../chapter-6-abstracting-evaluations/6.1-composing-operables.md) for operations, [compositions have a purpose](../chapter-5-evaluating-through-compositions/5.1-composing-contexts.md) which will create consistency behind this specific use of `{ }` for behaviors.
{% endhint %}

### Behavior Operations

Operations within a behavior can look exactly the same as the operations in the examples so far, but most likely they will have additional syntax that generally[^2] looks like `for {"Context Names"}`. This addition to the operation declaration specifies what contexts of the behavior are required for the operation, which makes the dependencies of the operation more explicit and is necessary for [cross-behavior evaluations](broken-reference).

The overall generalized syntax for an operation usually ends up [looking like](#user-content-fn-3)[^3]:

```
"Operation Identifier" ::
    "operation name with [Context Types]": <"Context Names"> 
        for {"Behavior Context Names"} "Qualifications"? 
            "Operation Logic".
```

### Logging

Logging[^4] is a relatively simple feature that can be implemented and expanded upon as more behavior concepts are described. To start logging, there will need to be a couple of contexts:

```
Log Settings: context.
Log Message: context String.
```

{% hint style="warning" %}
Notice how `Log Settings` has no data at all. It is technically an empty collection of properties, but for all intents and purposes, there is no value associated with it. This kind of context is called a "flag" in Contextual Programming. It does nothing but serve to flag the application as needing to enable some functionality through its existence.

`Log Settings` will have data associated with it later, but for now, it exists only to enable logging within the application.
{% endhint %}

Then the behavior declaration.

```
Perform Logging ::
    logging per Log Settings for Log Message: {settings, message}?
    {
        
    }.
```

Last, the actual logging, which for now will just be to the console.

```
Perform Logging ::
    logging per Log Settings for Log Message: {settings, message}?
    {
        Log :: for {message} when initialized?
            evaluate "Log: \(message)" as Console Message,
            \deactivate message;
    }.
```

There's not a lot to this behavior so far. Whenever there's an activated `Log Settings` and an activated `Log Message` that are both available, a new instance of this `Perform Logging` behavior will be created, bound to those contexts. When the behavior initializes (upon its creation), the `Log` operation will be performed using the behavior's `message`. That message will have `Log:` prepended, then the new log will be aliased as a `Console Message` to be output to the console, then the message will be deactivated.&#x20;

{% hint style="info" %}
This same functionality could be achieved with a standalone operation, but using a behavior like this will make the functionality easier to extend in the future.
{% endhint %}

Since `\deactivate` is used instead of `deactivate` (with no `\`) for the deactivation, the actual deactivation will happen separate of this operation's functionality, likely right after it, and not as part of it. The behavior exists due to both the settings and the message, so deactivating the message will destroy the behavior instance. With `Log Settings` no longer qualifying for any behavior, it will be deactivated by the runtime, so right now, this behavior is single use per `Log Settings` and `Log Message`. That's not particularly useful, so there will be one more behavior to take ownership of the `Log Settings`.

```
Maintain Log Settings ::
    maintain the existence of Log Settings: {settings}.
```

This behavior doesn't actually do anything explicitly, but by existing it will capture any instances of `Log Settings` and prevent them from being deactivated since they will always qualify for at least this behavior. Doing so follows the "Ownership" pattern[^5], where a behavior essentially declares that it will ensure the existence and destruction of a specific context, on the condition of that context's own state or until another context achieves a state that should cause the owner behavior to deactivate its owned context. Owner behaviors either aid in persisting a single context for the lifetime of the application or act as a way to congregate all instances of a type and determine when it is most appropriate to deactivate them.

The app initialization operation to log a message could be:

```
Hello Log :: when initialized?
    activate Log Settings,
    activate Log Message ["Hello Log!"].
```

In the above code, a `Log Settings` instance is created and activated, followed by a `Log Message` with the value of `"Hello Log!"` also being created and activated. This would be enough to initiate the behavior and output `Hello Log!` to the console.

{% hint style="info" %}
### Activating Together

Recall that behaviors are formed by whichever contexts happen to be available (after being activated). In cases where there are multiple instances of contexts, this may mean that contexts that are activated at different times end up being associated with one another in a behavior, even when other contexts were actually activated near each other, as was just done. This may be fine most of the time, as contexts often don't need to have specific relationships, but sometimes it may be important that they do.

Using the current code as an example, what if it was relevant for this specific `Log Settings` to be associated with this specific `Log Message` when the behavior is created? In that case, they can be activated together, like so:

`Hello Log :: when initialized?` \
&#x20;   activate {`Log Settings, Log Message ["Hello Log!"]}.`

This code evaluates the contexts together as a group, called a [composition](../chapter-5-evaluating-through-compositions/5.1-composing-contexts.md). This will associate the contexts with one another for any behavior considerations. In any place where they could belong to the same behavior, they will, but they will also still qualify for any behaviors where they are needed independent of each other.

While this is important to understand, it won't apply to future uses of the logger.
{% endhint %}

Logging a couple of messages could be done by:

```
Hello Log :: when initialized?
    activate Log Settings,
    activate Log Message ["Hello Log!"],
    activate Log Message ["Another log."].
```

In the above code, `Log Settings` and the first `Log Message` create in instance of the `Logging` behavior, resulting in `Hello Log!` being output. That first `Log Message` is then deactivated, which frees the `Log Settings` up to be associated with a new instance of `Logging`, which will occur when the second `Log Message` is activated.



## Conditional Behavior

One of the benefits of logging is having greater control over the type of messages that are logged. This can be achieved by having a log level for the `Log Settings`, to act as a minimum threshold for logs, and a log level for `Log Message`, like so:

<pre><code>Log Level: [Int]  `This is an <a data-footnote-ref href="#user-content-fn-6">enum</a> declaration.`
{
    <a data-footnote-ref href="#user-content-fn-7">Verbose</a>[0],
    <a data-footnote-ref href="#user-content-fn-8">Debug</a>[1],
    W<a data-footnote-ref href="#user-content-fn-9">arning</a>[2],
    <a data-footnote-ref href="#user-content-fn-10">Error</a>[3]
}.

Log Settings: context
{
    Minimum Level: Log Level [Log Level (Debug)];
}.

Log Message: context String
{
    Level: Log Level;
}.
</code></pre>

The `Logging` behavior can be updated to also be conditional now:

```
Perform Logging ::
    logging per Log Settings for Log Message: {settings, message}
        when message(Level) >= settings(Minimum Level)?
    {
        Log :: for {message} when initialized?
            evaluate "Log: \(message)" as Console Message,
            \deactivate message;
    }.
```

Now, only messages that have at least the minimum log level specified in the `Log Settings` will qualify to create an instance of the behavior and be logged to the console.

{% hint style="warning" %}
Any unqualified `Log Messages` will not be bound to the `Logging` behavior, so once they fall out of scope of their activating operation, they will be destroyed and removed from memory.
{% endhint %}

The updated app initialization operation could be:

```
Hello Log :: when initialized?
    activate Log Settings,
    activate Log Message ["Hello Log!", Level [Log Level (Debug)] ],
    activate Log Message ["A verbose log.", Level [Log Level (Verbose)] ].
```

The above code will create, and activate, the `Log Settings` with the default `Log Level (Debug)` as the `Minimum Level` required for logs to be output. Then it creates and activates the first `Log Message` with the `Log Level (Debug)` as its `Level` and the second with the `Log Level (Verbose)` as its `Level`. The second log won't be output since it won't meet the required minimum log level.

## Reactive Behavior

Earlier, an owner behavior for the `Log Settings` was introduced. It looked like:

```
Maintain Log Settings ::
    maintain the existence of Log Settings: {settings}.
```

This behavior ensures the `Log Settings` persists even when `Perform Logging` no longer qualifies due to there not being a `Log Message` available to be logged. However, it may not be desirable to have `Log Settings` persist unconditionally. One way this can be addressed is by adding a dependency to `Maintain Log Settings` and having it deactivate its `Log Settings` reactively, per changes to that dependency.

First, the context that will become the dependency needs to be declared. Since logging is usually an app-level feature that would only be stopped due to the application shutting down, this context can be an app-level context that defines the state of the app itself.

```
App State: context
{
    Continue Running : Bool [True];
},
this is shutting down: () => not this (Continue Running).
```

This is a simple context consisting only of a `Bool`, which defaults to `True`, that specifies whether the app will continue to run. There is a qualifier that is decorating the context, and which provides a readable way to determine whether the application is shutting down, e.g., that it will not continue to run. Note that the keyword `not` is used to negate the `Bool` of the `Continue Running` property.

Now, `Maintain Log Settings` can be updated:

```
Maintain Log Settings ::
    maintain the existence of Log Settings in accordance with App State: 
        {settings, app}?
    {
        Stop Logging :: for {settings, app} whenever app is shutting down?
            activate Log Message ["Stopping Logs", Level [Log Level (Debug)] ],
            deactivate settings;
    }.
```

This behavior now depends on `App State` and will reactively deactivate its `Log Settings` upon `App State (Continue Running)` becoming `False` (per the qualifier in `App State`), after activating one last `Log Message` that would qualify for `Perform Logging` and be output. Once the `Log Settings` are deactivated then `Perform Logging` will no longer qualify and any additional `Log Messages` will not be output.

The keyword in the `Stop Logging` operation's qualifications is `whenever`. This specifies that a reactive condition will follow, that "whenever the following is true, this functionality should occur", as opposed to `when` which specifies that "when attempting to evaluate, as explicitly stated to be done, and the following is true, this functionality should occur". `whenever` is only permitted within behaviors, since only behaviors have a persistent context that can qualify with `whenever`.

One more step is to maintain the existence of `App State`, again using the ownership pattern.

```
Maintain App State :: maintain the existence of App State: {app}?
{
    Cleanup App State :: for {app} whenever app is shutting down, after all?
        deactivate app;
}
```

The above owner behavior is similar to `Maintain Log Settings`. It takes ownership of `App State` to ensure it doesn't get automatically deactivated. Once `App State (Continue Running)` is False it will reactively deactivate `App State` after all other possible evaluations have occurred as a result of `Continue Running` becoming `False`.

The application initialization operation may become:

```
Hello Log :: when initialized?
    activate app: App State;
    activate Log Settings,
    activate Log Message ["Hello Log!", Level [Log Level (Debug)] ],
    activate Log Message ["A verbose log.", Level [Log Level (Verbose)] ],
    activate Log Message ["About to shut down!", Level [Log Level (Warning)] ],
    app(Continue Running) is False.
```

This application code will now create and activate the `App State` with the default `Continue Running` as `True`. It then proceeds as before, with a debug log, a verbose log (that is not output), and then a warning log that it is about the shutdown. `Continue Running` is set to `False` and the last log, "Stopping Logs", from `Maintain Log Settings` would be output with `Log Settings` and then `App State` being deactivated.

{% hint style="info" %}
The above with the two ownership behaviors, `Maintain Log Settings` and `Maintain App State` is a more detailed way to address the relationship between these two persistent contexts. There are [simpler ways](4.4-expanding-purpose.md) to set up these kinds of contexts and to perform cleanup when they no longer qualify for their behaviors.
{% endhint %}



## Understanding the Cycle

\[Detail how activate/deactivate qualifies for behaviors and performs initialization/termination operations immediately.]

\[Detail how reactive changes do not occur until the current operation chain completes to a 'continue' is used.]

\[Show through re-arranging the Hello Log operation how this flow works.]





[^1]: As a reminder, text within double quotations here would be replaced by text meaningful to an actual declaration. Text within square brackets signifies that specific names defined within the code should replace the text.

[^2]: Where text within double quotations is replaced by text meaningful to an actual declaration.

[^3]: As a reminder, text within double quotations here would be replaced by text meaningful to an actual declaration. Text within square brackets signifies that specific names defined within the code should replace the text.

[^4]: A logger is usually an abstraction for where the output of an application will be written, for example, whether it's to the console or a file. Loggers also may provide some control over exactly what is output.

[^5]: A pattern in programming describes an abstract way to achieve a specific result. Object-Oriented Programming is well-known to rely on patterns, sometimes to achieve a functional result and sometimes to structure code in a maintainable manner. Contextual Programming attempts to be inherently more maintainable, so usually only the former are required.

[^6]: Enums are collections of named values, in this case, a collection of named integers. The named values can be referenced as instances of the enum, or the underlying values (`Int` in this case) can be converted to instances of the enum if there is a matching named value.

[^7]: Verbose is the lowest level, it often designates logs that are only useful as information for in-depth tracking of what is happening in the application. Sometimes this level is actually called "Information".

[^8]: Debug designates logs as useful for debugging, but perhaps not necessary to confirm that the application is performing its primary functionality.

[^9]: Warning designates logs as a warning to functionality that may not be working correctly but is not an explicit error.

[^10]: Error is for logs that are output as the result of actual errors that occur and should be addressed.
