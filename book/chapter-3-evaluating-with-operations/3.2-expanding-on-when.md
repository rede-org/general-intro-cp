# 3.2  Expanding on 'When'

## Operation Conditions

In the[ Hello World example](3.1-hello-world.md), `when initialized` was introduced as a Circumstantial Control Flow qualification. However, `when` can specify many other qualifications. Most often these qualifications will be conditions that the contexts of an operation must meet for the operation to be performed.

A simple example can be one that checks whether an input number is even. As before, it's best to [define the context](../chapter-2-creating-context/2.1-organizing-data.md#defining-a-context) that we will use first:

```
Input Number: context Int.
```

Then the entry point to the application, where the user will be asked to provide a number:

```
Even Checker: when initialized?
    await "Please enter a number." as Console Message,
    await response: Console Response;
    await response to Input Number.
```

{% hint style="warning" %}
Notice how `response` is being mapped to an `Input Number` using the `to` keyword. `response` is a `Console Response` which is an alias for a `String` which, in Rede, has a built-in mapping to an `Int` which `Input Number` is an alias for. The full steps of what is occurring here are: `response` being checked for a direct mapping to `Input Number`, when this isn't found `response` is checked for a direct mapping to `Int`, when this isn't found `response` is de-aliased as a `String` which is checked for a mapping to `Input Number`, when this isn't found `response` (as a `String`) is checked for a mapping to an `Int`, which is found. The mapping is then attempted and the `Int` is aliased back to an `Input Number`.&#x20;

This mapping will attempt to map the `String` to an `Int` in any way that it can, and if it can't, then an error will be thrown. There are ways to check that a `String` and can be safely mapped to an `Int`, a couple of which are covered in later sections.
{% endhint %}

This initial operation requests a number from the user, then waits for the response, and then awaits any operations that handle the response as an `Input Number`. Here is an operation to do just that:

```
Notify Of An Even Input Number: <number> when number % 2 = 0?
    await "That number is even!" as Console Message.
```

This operation will be performed for an awaited `Input Number` which it will call `number`. `number` must be even (modulus[^1] 2, leaving no remainder) for the operation to be performed, as specified by `when number % 2 = 0`. Upon being performed, the operation sends a console message that the number is even.

It may be nice to also notify the user of when the number is not even, which can be done with this similarly looking operation:

```
Notify Of A Not Even Input Number: <number> when number % 2 = 1?
    await "That number is not even!" as Console Message.
```



## Operations with Multiple Contexts

\[Detail how Console Response can be aliased as an Unvalidated Int String, with a Validated Int String, which can then be safely converted to Input Number for other use. If Validate Int String (Is Valid Int) is false, then a different message can be provided.]

The initial implementation of the Even Checker doesn't validate whether the user actually provided a number. As is, it would crash for non-numerical input, which is usually not a desired result. The implementation can be updated to use aliases that will make use of Rede's built-in validation operations.

```
Even Checker: when initialized?
    await "Please enter a number." as Console Message,
    await response: Console Response;
    await <response as Unvalidated Int String, 
        validated response: Validated Int String;>,
    await validated response.
```

The initial operation has a new line `await <response as Unvalidated Int String, validated response: Validated Int String;>,` that aliases the response (an already aliased `String`) as an `Unvalidated Int String` (a built-in alias of `String`) and declares a new `validated response` which is another built-in context, `Validated Int String`. Awaiting these two contexts together will initiate an operation that validates the text of the `Unvalidated Int String` and updates the `Validated Int String` with the result.

`Validated Int String` is a context with two properties, `Is Valid Int`, which is a `Bool` (true or false), and `Value` which is the `String` that has been validated. If the `Value` can safely be converted to an `Int` then `Is Valid Int` is `True`. Knowing that, a new operation can be made to be performed from the initial operation's `await validated response`:

```
Initiate Validated Int String Check: <input> when input (Is Valid Int)?
    await input (Value) to Input Number.
```

The above operation will map the user's input `String` to the `Input Number` context and await that, which will initiate either `Notify Of An Even Input Number` or `Notify Of A Not Even Input Number` operation.

One benefit to this method of input validation is the ability to handle the invalid case, such as with this operation:

```
Notify User Of Bad Input For Validated Int String: <input> 
    when not input (Is Valid Int)?
        await "That is not a number." as Console Message.
```



## Qualifying Value Declarations

The validation performed in the last section is one way to ensure the application does not crash when converting invalid input to the expected data type. Another way this can be done is within an operation's qualifications, as shown with this operation:

```
Initiate Even Check For Console Response: <response>
    number: response to Input Number?
        await number.
```

This operation will occur for the same `await response: Console Response` that is specified in the initial operation. It will take that user's response and attempt to declare a new value for the operation that maps the response to an `Input Number`. If this fails for any reason, then the operation won't be performed, but the application will not crash, as this failure is treated the same as any other failure for a context's state to qualify for an operation. There are other scenarios in which values can be declared within the qualifications of an operation as well.

With this new operation performing the validation and the mapping, the initial operation can be changed to:

```
Even Checker: when initialized?
    await "Please enter a number." as Console Message,
    await !: Console Response.
```

{% hint style="info" %}
The last line here has a syntax different than shown with an await so far. `await !: Console Response` specifies that an instance of `Console Response` will be created, and awaited, but its value isn't needed for the remainder of this operation, so there is no name specified to complete the variable declaration.
{% endhint %}

However, the new operation, as is, might not always perform as desired, for reasons explained in the next section.



## Identifiers and Execution Order

When more than one operation qualifies for awaited context(s), the order of those operations being performed might matter, or it might not. Looking back at the last section's `Initiate Even Check For Console Response` operation, it's noteworthy that it takes the same `Console Response` context as some other built-in operation. That built-in operation is the operation that polls for the user's input to the console and then captures it within the `Console Response` context.

Both of these operations taking the same context is what permits the last section's `Even Checker` operation to be so simple, with that `await response: Console Response` line both getting the user's input and initiating the check for that input. However, this only works if the order of those operations' execution occurs as expected; specifically, `Initiate Even Check For Console Response` must occur after the context is populated with the user's input.

While there are ways to [work around this with an alias](3.2-expanding-on-when.md#conditional-awaits) and another `await`, Rede offers two concepts that provide a more direct solution. The first is an operation identifier. An identifier is an optional part of an operation's declaration that permits the operation to be identified by other operations. The identifier is any text that occurs before `::` in front of the operation's name, as in the following:

```
Check Response :: 
    Initiate Even Check For Console Response: <response>
        number: response to Input Number?
            await number.
```

This is the same `Initiate Even Check for Console Response` operation as before, but now it has an identifier, `Check Response`, which allows other operations to refer to this operation.

{% hint style="info" %}
The formatting here is irrelevant, but putting the identifier on its own line can elevate its apparent importance to future programmers.
{% endhint %}

{% hint style="warning" %}
While operation names are mostly for describing the operation to other programmers, an operation's identifier will be used to refer to the operation in other places, so it needs to be unique (relative to namespacing[^2] and [groups](3.3-operation-groups.md)), but it may be desirable to also not make it too long.
{% endhint %}

With a way to identify operations, there can be Relational Control Flow, where operations define their control flow relative to one another. This control flow is defined by keywords, such as `after` and `before`. Using this control flow, `Check Response` can have its order relative to the identified `Capture Console Input As Response` specified explicitly:

```
Check Response :: 
    Initiate Even Check For Console Response: <response>
        after Capture Console Input As Response,
        number: response to Input Number?
            await number.
```

{% hint style="info" %}
While `Check Response` does not really need its identifier here, it's a good practice to provide identifiers for operations that are relational to other specific operations, if only for future ease of extending that control flow with more operations. In general, operations without identifiers are not open to relational control flow, so whether an operation has an identifier should depend on the intended use of its codebase or whether the responsibilities of its contexts should be able to be extended through related operations.
{% endhint %}

There is a statement for Relational Control Flow in Rede that is sufficient in this specific use case and removes the necessity for the identifiers though:

```
Initiate Even Check For Console Response: <response> after all,
    number: response to Input Number?
        await number.
```

In specifying `all` after `after`, `Initiate Even Check For Console Response` will occur after all other operations for `Console Response` have completed. Be careful though, this is not very extendible with more operations, as this operation will now always try to occur last (or at the same time as another operation that wants to be last).



## Conditional Awaits

\[Detail how awaits can be conditionally chained with or and and.]

[^1]: Modulus is represented by `%` in Rede, as it is in many other languages as well.

[^2]: Namespacing is a way to group different program constructs together and to designate which group of constructs another part of code is explicitly using.
