# 3.1  Hello World!

## Overview

For an application to progress, the state of its contexts must be changed. Operations are the constructs that, at a high-level, define when those contexts are changed/created, and at a more detailed level, how they are changed.

In general, a simple operation that has no required contexts has a declaration that looks like [the following](#user-content-fn-1)[^1]:

```
"Operation Name": "Qualifications"? "Operation Logic".
```

{% hint style="info" %}
An operation's name, shown as "Operation Name" above, can really be anything since it isn't directly referenced anywhere else in the code. It's recommended that these names are self-documenting[^2].
{% endhint %}

Qualifications are where the 'when' aspect of Contextual Programming is defined. Statements after the `:` and before the `?` are all considered qualifications and often take the form of `when "some condition"`, but they can also have other forms that will be shown later.

Operation logic is a series of statements that either creates new contexts, directly manipulates the operation's contexts (if it has any), or specifies other operations that may qualify to alter specific contexts.



## A Simple Operation

One of the simplest examples of an operation is Rede's (simplest[^3]) implementation of the classic "Hello World!" program:

```
Main: when initialized?
    await "Hello World!" as Console Message.
```

In [the first line](#user-content-fn-4)[^4], `Main: when initialized?`, there's the operation name, `Main`, and one qualification, `when initialized`. This qualification is referred to as a Circumstantial[^5] [Control Flow](#user-content-fn-6)[^6] qualification. When applied in this way, a `when initialized` will qualify for execution when the application starts, so this operation called `Main` will execute immediately when the application begins to execute.

The second line, `await "Hello World!" as Console Message.`, is the operation logic. This is what will actually be executed when `Main` qualifies and executes. There's a lot going on in this line:

* `await` is a command to the [runtime of the application](#user-content-fn-7)[^7]. It tells the runtime to perform operations that are qualified by the context(s) that follows it. `await` will require the runtime to perform any such operations before the current operation continues, unlike its counterpart `run`, which is not concerned about when the runtime will perform the operations. There are circumstances when `run` is more appropriate than `await`, primarily when what is expected to be accomplished by `run` is of no importance to the current chain of logic or should be done entirely asynchronously[^8].
* `"Hello World!"` is a string literal, which is to say it is an instance of a string[^9] type. This is defining the text that will be presented to the user.
* `as Console Message` is a command to [alias](../chapter-2-creating-context/2.3-adaptation.md#aliasing) the string `"Hello World!"` as a `Console Message` context type, which is a built-in context provided by the runtime. This will be done prior to the `run` command being evaluated by the runtime.

Altogether, `await "Hello World!" as Console Message.` is telling the application runtime to "take the text, 'Hello World!', alias it as a Console Message, and execute any operations that qualify for that context". The standard functionality of the runtime includes an operation that will qualify for a single `Console Message` and will perform logic that will result in `Hello World!` being displayed to the user through a console.

While not much, this operation shows how to send messages to the user through the console while following the practices of Contextual Programming.



\[Define an operation for a context to get the user's name, as input.]

\[Update Hello World to await the user's name and say Hello 'User'.]



[^1]: As before, text within double quotations here would be replaced by text meaningful to an actual declaration.

[^2]: Self-documenting means that the code serves its intended purpose as code but is also expressive enough when read to convey the actual use and meaning of the code, thus reducing the need to write separate documentation to provide that information.

[^3]: In programming, there are often multiple ways to accomplish the same goal. In this case, the simplest implementation is the shortest and most streamlined version, but it has less flexibility and provides less control than other implementations.

[^4]: This entire example could be on one line, but for readability and ease of explaining the concepts, it's been split over two lines.

[^5]: Meaning that it qualifies by a circumstance of the application itself, not necessarily the values of any specific state.

[^6]: Control flow is a programming term to describe how the execution path of an application is determined. Most paradigms/languages define control flow through branches (if/else, switch) and loops (while/for), although how the application reaches those branches may sometimes be abstracted away through other means. Most control flow in Contextual Programming is defined through the qualifications of operations.

[^7]: An application's runtime is the core of the application that is defined by the programming language. In the case of Rede, it includes the systems that keep track of the application's contexts, determine what operations should execute when, and ultimately communicates the intent of the programmer (from their code) to the operating system.

[^8]: Asynchronous functionality is logic that is performed at the same time as other logic, sometimes on a separate core of the computer's processor if possible. Performing logic asynchronously can reduce overall execution time to complete a task that can be safely distributed across execution environments (like different cores).

[^9]: Strings are a sequence of characters. They are essentially text.
